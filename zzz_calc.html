<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Zenless Zone Zero Analyzer</title>
  <style>
    :root { --b:#ddd; --muted:#666; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 22px; max-width: 1180px; }
    h1 { margin: 0 0 10px; }
    h2 { margin: 22px 0 10px; font-size: 18px; }
    .muted { color: var(--muted); font-size: 13px; line-height: 1.35; }
    .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; border:1px solid var(--b); font-size: 12px; background:#fafafa; margin: 2px 4px 2px 0; }
    .card { border: 1px solid var(--b); border-radius: 14px; padding: 14px 16px; background: #fff; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px 16px; }
    .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px 16px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: end; }
    .row > * { flex: 1; min-width: 220px; }
    label { display: flex; flex-direction: column; gap: 6px; font-size: 14px; }
    label > input, label > select { align-self: stretch; }
    input, select { padding: 9px 10px; border: 1px solid #cfcfcf; border-radius: 12px; font-size: 14px; }
    input[type="checkbox"] { width: 18px; height: 18px; }
    .btn { padding: 10px 12px; border-radius: 12px; border: 1px solid #cfcfcf; background: #f7f7f7; cursor: pointer; font-size: 14px; }
    .btn.primary { background: #eef5ff; border-color: #b9d3ff; }
    .btn:active { transform: translateY(1px); }
    pre { background:#fafafa; border:1px solid #eee; padding:12px; border-radius:14px; overflow:auto; margin: 0; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px 8px; border-bottom: 1px solid #eee; font-size: 14px; }
    th { font-size: 12px; color: var(--muted); font-weight: 650; letter-spacing: .02em; text-transform: uppercase; }
    .kpi { display:flex; gap:10px; flex-wrap: wrap; }
    .kpi .box { border:1px solid #eee; border-radius: 12px; padding:10px 12px; background:#fcfcfc; min-width: 240px; }
    .kpi .box .t { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .kpi .box .v { font-size: 16px; font-weight: 650; }
    .hr { height:1px; background:#eee; margin: 14px 0; }
    .hidden { display:none !important; }
  </style>
</head>

<body>
  <h1>Zenless Zone Zero — Damage Inputs + “Diminishing Returns” Analyzer</h1>

  <!-- Identity / save -->
  <div class="card" style="margin-top:12px;">
    <div class="row">
      <label>Build Name <input id="buildName" value="My Build"/></label>
      <label>Enemy Preset ID <input id="enemyPresetId" value="Enemy Default"/></label>
      <label>
        Mode
        <select id="mode">
          <option value="standard">Standard DMG</option>
          <option value="anomaly">Anomaly</option>
          <option value="rupture">Rupture (Sheer DMG)</option>
          <option value="hybrid">Hybrid (Standard + Anomaly)</option>
        </select>
      </label>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="btnSave">Save (Local)</button>
      <button class="btn" id="btnLoad">Load (Local)</button>
      <button class="btn" id="btnExport">Export JSON</button>
      <button class="btn" id="btnImport">Import JSON</button>
      <input id="importFile" type="file" accept="application/json" class="hidden" />
      <button class="btn" id="btnReset">Reset</button>
    </div>
  </div>

  <h2>Agent Stats</h2>
  <div class="card grid3">
    <label>ATK <input id="atkBase" type="number" value="1000" min="0" step="1"/></label>
    <label><s>ATK Bonus (In-Combat)</s> <input id="atkFlatBonus" type="number" value="0" min="0" step="1"/></label>
    <label>Skill Multiplier (%) <input id="skillMultPct" type="number" value="100" min="0" step="0.1"/>
    </label>
        <label>Agent Level <input id="agentLevel" type="number" value="60" min="1" step="1"/></label>

    <label>Crit Rate (%) <input id="critRatePct" type="number" value="5" min="0" max="100" step="0.1"/></label>
    <label>Crit DMG (%) <input id="critDmgPct" type="number" value="50" min="0" step="0.1"/></label>
<label>
      Attribute
      <select id="attribute">
        <option value="physical">Physical</option>
        <option value="fire">Fire</option>
        <option value="ice">Ice</option>
        <option value="electric">Electric</option>
        <option value="ether">Ether</option>
      </select>
    </label>

    <label><s>Flat “Special Multiplier” (Optional)</s> <input id="specialMult" type="number" value="1" step="0.01"/></label>
    
    <label>Generic DMG% <input id="dmgGenericPct" type="number" value="0" step="0.1"/></label>
    <label>Attribute DMG% <input id="dmgAttrPct" type="number" value="0" step="0.1"/></label>
    <label>Skill DMG% (Basic/Special/Ult) <input id="dmgSkillTypePct" type="number" value="0" step="0.1"/></label>

    <label>Anomaly DMG% <input id="anomDmgPct" type="number" value="0" step="0.1"/></label>
    <label>Disorder DMG% <input id="disorderDmgPct" type="number" value="0" step="0.1"/></label>
    <label><s>Other DMG%</s> <input id="dmgOtherPct" type="number" value="0" step="0.1"/></label>

    <label>PEN Ratio (%) <input id="penRatioPct" type="number" value="0" step="0.1"/></label>
    <label>PEN <input id="penFlat" type="number" value="0" step="1"/></label>
    
</div>

  <h2 id="anomalyHeader">Anomaly</h2>
  <div class="card" id="anomalyCard">
    <div class="grid3">
      <label>Anomaly Mastery <input id="anomMastery" type="number" value="0" step="1"/></label>
      <label>Anomaly Proficiency <input id="anomProf" type="number" value="0" step="1"/></label>
      <label>Base Anomaly DMG <input id="anomBaseManual" type="number" value="0" step="1"/></label>

      <label>Triggers Per Rotation <input id="anomTriggersPerRot" type="number" value="0" step="0.1"/></label>
      <label>Disorder Triggers Per Rotation <input id="disorderTriggersPerRot" type="number" value="0" step="0.1"/></label>
      <label>Anomaly Special Multiplier <input id="anomSpecialMult" type="number" value="1" step="0.01"/></label>
    </div>
  </div>

  <h2 id="ruptureHeader">Rupture — Sheer Force / Sheer DMG Bonus</h2>
  <div class="card" id="ruptureCard">
    <div class="grid3">
      <label>Sheer Force <input id="sheerForce" type="number" value="0" step="1"/></label>
      <label>Sheer DMG Bonus (%) <input id="sheerDmgBonusPct" type="number" value="0" step="0.1"/></label>
      <label><s>ATK →  Sheer Conversion (%)</s> <input id="atkToSheerPct" type="number" value="30" step="0.1"/></label>
    </div>
  </div>

  <h2>Enemy</h2>
  <div class="card">

    <div class="grid3">
      <label>Enemy Level <input id="enemyLevel" type="number" value="70" min="1" step="1"/></label>
      <label>Enemy DEF <input id="enemyDef" type="number" value="953" min="0" step="1"/></label>
      <label>Enemy Attribute RES (%) <input id="enemyResPct" type="number" value="0" step="0.1"/></label>

      <label>DEF Reduction (%) <input id="defReductionPct" type="number" value="0" step="0.1"/></label>
      <label>DEF Ignore (%) <input id="defIgnorePct" type="number" value="0" step="0.1"/></label>
      <label>
        <s>DEF Multiplier Override (Optional)</s>
        <input id="defMultOverride" type="number" value="" step="0.01" />
      </label>
      <label>
        <s>Enemy Damage Taken Multiplier (Optional)</s>
        <input id="enemyDmgTakenMult" type="number" value="" step="0.01" />
      </label>
      <label>Damage Taken +% (Vulnerability) <input id="dmgTakenPct" type="number" value="0" step="0.1"/></label>
      <label>Stunned? <select id="isStunned"><option value="false">No</option><option value="true">Yes</option></select></label>
      <label>
        Stunned Multiplier (%)
        <input id="stunPct" type="number" value="100" step="1" />
      </label>
      <label>Stunned Damage Taken +% <input id="dmgTakenStunnedPct" type="number" value="0" step="0.1"/></label>
      <label>Stunned DMG% <input id="dmgVsStunnedPct" type="number" value="0" step="0.1"/></label>
      <label><s>  Daze Vulnerability Multiplier</s> <input id="dazeVulnMult" type="number" value="1" step="0.01"/></label>
    </div>
  </div>

  <h2>Outputs + Marginal Value (Diminishing Returns)</h2>
  <div class="card">
    <div class="kpi" id="kpi"></div>

    <div class="hr"></div>

    <div class="row">
      <label>
        Marginal analysis step size
        <select id="deltaPreset">
          <option value="1">+1% (for % stats), +10 ATK, +10 PEN</option>
          <option value="5">+5% (for % stats), +50 ATK, +50 PEN</option>
          <option value="10">+10% (for % stats), +100 ATK, +100 PEN</option>
        </select>
      </label>
      <label>
        Comparison basis (Drive Disc equivalence)
        <select id="marginalBasis">
          <option value="raw" selected>Raw step size above</option>
          <option value="main">Drive Disc main stat equivalence</option>
          <option value="sub">Substat roll equivalence</option>
        </select>
      </label>

      <label>
        Assume Crit Rate fixed at current value?
        <select id="critRateFixed">
          <option value="true">Yes (increase Crit DMG only)</option>
          <option value="false">No (allow Crit Rate step too)</option>
        </select>
      </label>
      <label>
        Show top N most efficient stats
        <select id="topN">
          <option value="6">6</option><option value="10" selected>10</option><option value="14">14</option>
        </select>
      </label>
    </div>

    <div class="hr"></div>

    <div class="muted" style="margin-bottom:8px;">
      Table shows: “If we add a small amount to this stat (step size above), how much does expected output increase?”
      Additive zones will show diminishing returns automatically (if already large).
    </div>

    <table>
      <thead>
        <tr>
          <th>Stat</th>
          <th>Δ Applied</th>
          <th>New Output</th>
          <th>Gain</th>
          <th>% Gain</th>
          <th>Why it matters</th>
        </tr>
      </thead>
      <tbody id="marginalBody"></tbody>
    </table>

    <div class="hr"></div>

    
  </div>

<script>
  // ===========================
  // Helpers
  // ===========================
  const $ = (id) => document.getElementById(id);
  const num = (id, fallback = 0) => {
    const el = $(id);
    const v = el?.value;
    if (v === "" || v === null || v === undefined) return fallback;
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  };

  // Optional numeric input: returns null when blank/invalid
  const optNum = (id) => {
    const el = $(id);
    const v = el?.value;
    if (v === "" || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const pctToMult = (pct) => 1 + (pct / 100);

  // Round half-up (0.5 always rounds up; negative values round away from zero)
  function roundHalfUp(value, decimals = 2) {
    const f = 10 ** decimals;
    if (!Number.isFinite(value)) return value;
    const x = value * f;
    const r = value >= 0 ? Math.floor(x + 0.5) : Math.ceil(x - 0.5);
    return r / f;
  }

  function fmt(value, decimals = 2) {
    const r = roundHalfUp(value, decimals);
    // Keep trailing zeros like toFixed, but don't change rounding behavior
    return Number.isFinite(r) ? r.toFixed(decimals) : String(value);
  }

  // UI formatting helpers (half-up). Calculations remain full precision.
  const fmt0 = (v) => fmt(v, 0);
  const fmt1 = (v) => fmt(v, 1);

  // ZZZ-like DEF multiplier (Level Factor table + effective DEF with PEN ratio and flat PEN)
  // Based on common community formula: DEF Mult = LF / (effectiveDEF + LF)
  // where effectiveDEF = max( DEF*(1-penRatio) - penFlat, 0 ). LF is a level-based constant.
  function levelFactor(level) {
    // Table for 1..59; 60+ treated as 794 (commonly used).
    const t = [null,
      50,54,58,62,66,71,76,82,88,94,
      100,107,114,121,129,137,145,153,162,172,
      181,191,201,211,222,233,245,256,268,281,
      293,306,319,333,347,361,375,390,405,421,
      436,452,469,485,502,519,537,555,573,592,
      610,629,649,669,689,709,730,751,772
    ];
    if (level >= 60) return 794;
    return t[level] ?? 794;
  }

  function computeDefMult(i) {
    const lf = levelFactor(i.agent.level);

    // Start from enemy DEF input
    let def = Math.max(0, i.enemy.def);

    // Apply DEF reduction (shred) as scaling on DEF (kept separate by UI)
    def *= (1 - (i.enemy.defReductionPct / 100));

    // Apply PEN ratio and flat PEN
    def = def * (1 - (i.agent.penRatioPct / 100)) - i.agent.penFlat;

    // Apply DEF Ignore as an additional "ignore remaining DEF" knob (distinct from PEN ratio)
    def *= (1 - (i.agent.defIgnorePct / 100));

    def = Math.max(0, def);
    return lf / (def + lf);
  }

  function storageKey(enemyPresetId) {
    return `zzz_calc.builds.${enemyPresetId}`;
  }

  // ===========================
  // Read inputs (schema v2)
  // ===========================
  function readInputs() {
    const mode = $("mode").value;
    const stunned = $("isStunned").value === "true";

    const dmgBuckets = {
      generic: num("dmgGenericPct"),
      attribute: num("dmgAttrPct"),
      skillType: num("dmgSkillTypePct"),
      other: num("dmgOtherPct"),
      vsStunned: stunned ? num("dmgVsStunnedPct") : 0,
      anomaly: (mode === "anomaly" || mode === "hybrid") ? num("anomDmgPct") : 0,
      disorder: (mode === "anomaly" || mode === "hybrid") ? num("disorderDmgPct") : 0,
    };

    return {
      schemaVersion: 3,
      buildName: $("buildName").value.trim() || "My Build",
      enemyPresetId: $("enemyPresetId").value.trim() || "enemy_default",
      mode,

      agent: {
        level: Math.max(1, Math.floor(num("agentLevel", 60))),
        atkBase: num("atkBase", 2000),
        atkFlatBonus: num("atkFlatBonus", 0),
        attribute: $("attribute").value,
        skillMultPct: num("skillMultPct", 300),
        specialMult: num("specialMult", 1),

        crit: {
          rate: clamp(num("critRatePct", 50) / 100, 0, 1),
          dmg: Math.max(0, num("critDmgPct", 100) / 100)
        },

        dmgBuckets,

        // Distinct defense interaction inputs
        penRatioPct: Math.max(0, num("penRatioPct")),
        penFlat: Math.max(0, num("penFlat")),
        defIgnorePct: Math.max(0, num("defIgnorePct")),

        rupture: {
          sheerForce: Math.max(0, num("sheerForce")),
          sheerDmgBonusPct: num("sheerDmgBonusPct"),
          atkToSheerPct: num("atkToSheerPct")
        },

        anomaly: {
          mastery: Math.max(0, num("anomMastery")),
          proficiency: Math.max(0, num("anomProf")),
          baseManual: Math.max(0, num("anomBaseManual")),
          triggersPerRot: Math.max(0, num("anomTriggersPerRot")),
          disorderTriggersPerRot: Math.max(0, num("disorderTriggersPerRot")),
          specialMult: num("anomSpecialMult")
        }
      },

      enemy: {
        level: Math.max(1, Math.floor(num("enemyLevel", 60))),
        def: Math.max(0, Math.floor(num("enemyDef", 0))),
        resPct: num("enemyResPct", 0),

        defReductionPct: num("defReductionPct", 0),
        defMultOverride: optNum("defMultOverride"),
        enemyDmgTakenMult: optNum("enemyDmgTakenMult"),

        dmgTakenPct: num("dmgTakenPct", 0),
        stunned,
        stunPct: num("stunPct", 100),
        dmgTakenStunnedPct: stunned ? num("dmgTakenStunnedPct", 0) : 0,
        dazeVulnMult: num("dazeVulnMult", 1)
      },

      meta: { updatedAt: new Date().toISOString() }
    };;
  }

  // ===========================
  // Preview output model
  // (Structure-first: zones multiply; inside-zone % add)
  // ===========================
  function computeZones(i) {
    // ATK zone: use the ATK value at the moment of impact.
    // We model this as "Base ATK (Character)" + "Flat ATK Bonus (In-Combat)".
    const atkTotal = (i.agent.atkBase + i.agent.atkFlatBonus);
    const atkEffective = atkTotal;

    // Base skill zone
    const base = atkEffective * (i.agent.skillMultPct / 100);

    // DMG% zone: additive within buckets
    // We keep anomaly/disorder buckets separate but still additive into the DMG zone for preview;
    // later you can fork anomaly formula entirely (ZZZ has separate anomaly dmg type). :contentReference[oaicite:8]{index=8}
    const dmgPctTotal =
      i.agent.dmgBuckets.generic +
      i.agent.dmgBuckets.attribute +
      i.agent.dmgBuckets.skillType +
      i.agent.dmgBuckets.other +
      i.agent.dmgBuckets.vsStunned;

    const dmgMult = pctToMult(dmgPctTotal);

    // Crit zone
    const critRate = i.agent.crit.rate;
    const critDmg = i.agent.crit.dmg;
    const critMult_expected = 1 + (critRate * critDmg);

    // RES zone
    const resMult = 1 - (i.enemy.resPct / 100);

    // DEF zone: placeholder unless manual override checked
    // We keep distinct inputs (def ignore/pen/pen ratio/def shred) and display them,
    // but we do not “fake” an official formula here. You’ll wire your chosen DEF model later.
    const defMult = (i.enemy.defMultOverride !== null && i.enemy.defMultOverride !== undefined)
      ? clamp(i.enemy.defMultOverride, 0, 1)
      : computeDefMult(i);

    // Target-side zone (damage taken)
    const dmgTakenPctTotal = i.enemy.dmgTakenPct + i.enemy.dmgTakenStunnedPct;
    const dmgTakenMultOverride = (i.enemy.enemyDmgTakenMult !== null && i.enemy.enemyDmgTakenMult !== undefined)
      ? Math.max(0, i.enemy.enemyDmgTakenMult)
      : 1;
    const dmgTakenMult = pctToMult(dmgTakenPctTotal) * dmgTakenMultOverride;

    // Stun & Daze vulnerability zones
    const stunMult = i.enemy.stunned ? (i.enemy.stunPct / 100) : 1;
    const dazeVulnMult = i.enemy.stunned ? i.enemy.dazeVulnMult : 1;

    // Special zone (misc multiplier)
    const specialMult = i.agent.specialMult;

    return {
      atkTotal,
      atkEffective,
      base,
      dmgPctTotal,
      dmgMult,
      critRate,
      critDmg,
      critMult_expected,
      defMult,
      resMult,
      dmgTakenMult,
      stunMult,
      dazeVulnMult,
      specialMult
    };
  }

  function computePreviewOutput(i) {
    const z = computeZones(i);

    // Standard damage (per-hit): show Non-Crit, Crit, and Expected (by Crit Rate)
    const nonCritPerHit =
      z.base *
      z.dmgMult *
      /* crit */ 1 *
      z.defMult *
      z.resMult *
      z.dmgTakenMult *
      z.stunMult *
      z.dazeVulnMult *
      z.specialMult;

    const critPerHit = nonCritPerHit * (1 + z.critDmg);
    const expectedPerHit = nonCritPerHit * (1 + (z.critRate * z.critDmg));

    const nonCritTotal = nonCritPerHit;
    const critTotal = critPerHit;
    const expectedTotal = expectedPerHit;
    // Anomaly placeholders (manual)
    const anomalyMult = pctToMult(i.agent.dmgBuckets.anomaly || 0);
    const disorderMult = pctToMult(i.agent.dmgBuckets.disorder || 0);
    const anomalyPerTrigger = i.agent.anomaly.baseManual * anomalyMult * i.agent.anomaly.specialMult;
    const disorderPerTrigger = i.agent.anomaly.baseManual * disorderMult * i.agent.anomaly.specialMult;

    const anomalyPerRot = anomalyPerTrigger * i.agent.anomaly.triggersPerRot;
    const disorderPerRot = disorderPerTrigger * i.agent.anomaly.disorderTriggersPerRot;

    // Rupture placeholders: Sheer Force as base “attack-like” stat, then Sheer DMG Bonus% as additive zone
    // (Exact unit formula can differ; UI captures everything cleanly.) :contentReference[oaicite:9]{index=9}
    const sheerFromAtk = z.atkEffective * (i.agent.rupture.atkToSheerPct / 100);
    const sheerForceEffective = i.agent.rupture.sheerForce + sheerFromAtk;
    const sheerDmgMult = pctToMult(i.agent.rupture.sheerDmgBonusPct);
    const sheerPerHit = sheerForceEffective * (i.agent.skillMultPct / 100) * sheerDmgMult * z.resMult * z.dmgTakenMult * z.stunMult * z.dazeVulnMult * z.specialMult;

    // Mode output (provide Non-Crit / Crit / Expected for Standard DMG)
    let outputNonCrit = nonCritTotal;
    let outputCrit = critTotal;
    let outputExpected = expectedTotal;

    if (i.mode === "anomaly") {
      // Attribute Anomalies cannot crit (per common community formula references).
      outputNonCrit = anomalyPerRot + disorderPerRot;
      outputCrit = outputNonCrit;
      outputExpected = outputNonCrit;
    }
    if (i.mode === "rupture") {
      // Rupture path is currently modeled without crit; treat as same for all three.
      outputNonCrit = sheerPerHit;
      outputCrit = outputNonCrit;
      outputExpected = outputNonCrit;
    }
    if (i.mode === "hybrid") {
      const add = anomalyPerRot + disorderPerRot;
      outputNonCrit = nonCritTotal + add;
      outputCrit = critTotal + add;
      outputExpected = expectedTotal + add;
    }

    const output = outputExpected;
return {
      zones: z,

      // Standard DMG breakdown (per-hit and total)
      standard_noncrit_per_hit: nonCritPerHit,
      standard_crit_per_hit: critPerHit,
      standard_expected_per_hit: expectedPerHit,
      standard_noncrit_total: nonCritTotal,
      standard_crit_total: critTotal,
      standard_expected_total: expectedTotal,

      anomaly_total: anomalyPerRot + disorderPerRot,
      rupture_total: sheerPerHit,

      output_noncrit: outputNonCrit,
      output_crit: outputCrit,
      output_expected: outputExpected,
      output
    };
  }

  // ===========================
  // Diminishing returns / marginal value table
  // ===========================
  
  function getDeltaConfig() {
    const p = Number($("deltaPreset").value);
    const basis = $("marginalBasis") ? $("marginalBasis").value : "raw";

    // User-provided Drive Disc equivalence (typical rolls):
    // Main stat: PEN Ratio 24 = Element DMG% 30 = HP% 30
    // Substat:   Crit Rate 2.4 = Crit DMG 4.8 = HP% 3
    const equiv = {
      main: { penRatioPct: 24, dmgAttrPct: 30, hpPct: 30, critRatePct: null, critDmgPct: null },
      sub:  { penRatioPct: null, dmgAttrPct: null, hpPct: 3,  critRatePct: 2.4, critDmgPct: 4.8 }
    };

    return {
      basis,
      raw: { pct: p, atkFlat: p * 10, penFlat: p * 10 },
      equiv
    };
  }

  function getDeltaForKey(key, i, cfg) {
    // Returns { kind: "pct"|"flat"|"mult", value: number }
    const raw = cfg.raw;

    // Raw mode = original behavior
    if (cfg.basis === "raw") {
      if (key === "atkFlatBonus") return { kind: "flat", value: raw.atkFlat };
      if (key === "penFlat" || key === "sheerForce") return { kind: "flat", value: raw.penFlat };
      return { kind: "pct", value: raw.pct };
    }

    // Equivalence modes
    const eq = cfg.equiv[cfg.basis] || {};

    // Helper: fall back to raw pct if no equivalence exists for that stat
    const pctOrRaw = (v) => (typeof v === "number" && !Number.isNaN(v)) ? v : raw.pct;

    switch (key) {
      // ATK is modeled as flat in-combat bonus only.
      case "atkFlatBonus":
        return { kind: "flat", value: raw.atkFlat };

      // Element DMG% equivalence (Drive Disc main stat)
      case "dmgAttrPct":
        return { kind: "pct", value: pctOrRaw(eq.dmgAttrPct) };

      // PEN Ratio equivalence (Drive Disc main stat)
      case "penRatioPct":
        return { kind: "pct", value: pctOrRaw(eq.penRatioPct) };

      // Crit equivalence (Drive Disc substat)
      case "critRatePct":
        return { kind: "pct", value: pctOrRaw(eq.critRatePct) };
      case "critDmgPct":
        return { kind: "pct", value: pctOrRaw(eq.critDmgPct) };

      // Everything else: keep raw step so the table stays populated and consistent
      default:
        if (key === "penFlat" || key === "sheerForce") return { kind: "flat", value: raw.penFlat };
        if (key === "atkFlatBonus") return { kind: "flat", value: raw.atkFlat };
        return { kind: "pct", value: raw.pct };
    }
  }


  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  
  function applyDelta(i, key, deltaCfg) {
    const j = clone(i);
    const d = getDeltaForKey(key, i, deltaCfg);

    const dp = (d.kind === "pct") ? d.value : deltaCfg.raw.pct;   // percent points
    const df = (d.kind === "flat") ? d.value : deltaCfg.raw.penFlat;

    switch (key) {
      // ATK zone
      case "atkFlatBonus": j.agent.atkFlatBonus += df; break;

      // DMG% additive zone
      case "dmgGenericPct": j.agent.dmgBuckets.generic += dp; break;
      case "dmgAttrPct": j.agent.dmgBuckets.attribute += dp; break;
      case "dmgSkillTypePct": j.agent.dmgBuckets.skillType += dp; break;
      case "dmgOtherPct": j.agent.dmgBuckets.other += dp; break;
      case "dmgVsStunnedPct": j.agent.dmgBuckets.vsStunned += dp; break;

      // Crit zone
      case "critRatePct":
        j.agent.crit.rate = clamp(j.agent.crit.rate + (dp / 100), 0, 1); break;
      case "critDmgPct":
        j.agent.crit.dmg += (dp / 100); break;

      // Target-side zone
      case "dmgTakenPct": j.enemy.dmgTakenPct += dp; break;
      case "dmgTakenStunnedPct": j.enemy.dmgTakenStunnedPct += dp; break;
      case "stunPct": j.enemy.stunPct += dp; break;
      case "dazeVulnMult":
        // This is a direct multiplier, not a displayed %. Keep raw behavior: +0.05 per +5% preset.
        // For equivalence modes, we still tie it to the raw preset step.
        j.enemy.dazeVulnMult += 0.05 * (deltaCfg.raw.pct / 5); break;

      // Defense interaction knobs
      case "defReductionPct": j.enemy.defReductionPct += dp; break;
      case "penRatioPct": j.agent.penRatioPct += dp; break;
      case "penFlat": j.agent.penFlat += df; break;
      case "defIgnorePct": j.agent.defIgnorePct += dp; break;

      // Rupture
      case "sheerForce": j.agent.rupture.sheerForce += df; break;
      case "sheerDmgBonusPct": j.agent.rupture.sheerDmgBonusPct += dp; break;

      // Anomaly
      case "anomDmgPct": j.agent.dmgBuckets.anomaly += dp; break;
      case "disorderDmgPct": j.agent.dmgBuckets.disorder += dp; break;

      default: break;
    }
    return { j, applied: d };
  }


  function statMeta() {
    return [
      { key:"atkFlatBonus", label:"Flat ATK Bonus (In-Combat)", delta:"(+ATK)", why:"Base scaling zone (multiplies with DMG/Crit/etc)." },

      { key:"dmgGenericPct", label:"Generic DMG% (additive)", delta:"(+%)", why:"Additive inside DMG zone → diminishing returns when high." },
      { key:"dmgAttrPct", label:"Attribute DMG% (additive)", delta:"(+%)", why:"Same DMG zone; separated for clarity and future toggles." },
      { key:"dmgSkillTypePct", label:"Skill-type DMG% (additive)", delta:"(+%)", why:"Same DMG zone; important for kit-specific bonuses." },
      { key:"dmgOtherPct", label:"Other DMG% (additive)", delta:"(+%)", why:"Catch-all DMG% bucket." },
      { key:"dmgVsStunnedPct", label:"DMG% vs Stunned (additive)", delta:"(+%)", why:"Only matters during stun; still additive in DMG zone." },

      { key:"critRatePct", label:"CRIT Rate", delta:"(+%)", why:"Crit zone. Improves expected value until near 100%." },
      { key:"critDmgPct", label:"CRIT DMG", delta:"(+%)", why:"Crit zone. Multiplies after DMG zone in expected damage." },

      { key:"dmgTakenPct", label:"Enemy Damage Taken +%", delta:"(+%)", why:"Target-side zone; multiplies with your DMG/Crit zones." },
      { key:"dmgTakenStunnedPct", label:"Damage Taken +% while Stunned", delta:"(+%)", why:"Target-side; only meaningful in stun state." },
      { key:"stunPct", label:"Stun damage taken (%)", delta:"(+%)", why:"Enemy-side multiplier during stun windows (e.g., 125 = 1.25×)." },
      { key:"dazeVulnMult", label:"Daze vulnerability multiplier", delta:"(+mult)", why:"Extra vulnerability zone (manual input)." },

      // Defense knobs (separate)
      { key:"defReductionPct", label:"DEF Reduction (shred)", delta:"(+%)", why:"Distinct from PEN/PEN Ratio/DEF Ignore; effect depends on DEF model." },
      { key:"penRatioPct", label:"PEN Ratio (% DEF ignored)", delta:"(+%)", why:"Distinct knob; often interacts multiplicatively with DEF reduction. :contentReference[oaicite:10]{index=10}" },
      { key:"penFlat", label:"PEN (flat)", delta:"(+flat)", why:"Distinct knob; best vs lower DEF targets." },
      { key:"defIgnorePct", label:"DEF Ignore (%)", delta:"(+%)", why:"Distinct from PEN Ratio; keep separate for official wiring." },

      // Rupture
      { key:"sheerForce", label:"Sheer Force", delta:"(+flat)", why:"Rupture-only stat driving Sheer DMG. :contentReference[oaicite:11]{index=11}" },
      { key:"sheerDmgBonusPct", label:"Sheer DMG Bonus%", delta:"(+%)", why:"Rupture-only DMG% bonus stat. :contentReference[oaicite:12]{index=12}" },

      // Anomaly
      { key:"anomDmgPct", label:"Anomaly DMG%", delta:"(+%)", why:"Anomaly bucket (when modeling anomaly damage separately)." },
      { key:"disorderDmgPct", label:"Disorder DMG%", delta:"(+%)", why:"Disorder bucket (when modeling disorder separately)." },
    ];
  }

  function computeMarginals(i) {
    const base = computePreviewOutput(i);
    const baseOut = base.output;

    const deltaCfg = getDeltaConfig();
    const allowCritRate = $("critRateFixed").value === "false";

    const rows = [];
    for (const m of statMeta()) {
      if (!allowCritRate && m.key === "critRatePct") continue;

      // Skip irrelevant modes (optional filtering)
      if (i.mode !== "rupture" && (m.key === "sheerForce" || m.key === "sheerDmgBonusPct")) continue;
      if (i.mode === "standard" && (m.key === "anomDmgPct" || m.key === "disorderDmgPct")) continue;

      const { j, applied } = applyDelta(i, m.key, deltaCfg);
      const out2 = computePreviewOutput(j).output;
      const gain = out2 - baseOut;
      const pctGain = baseOut !== 0 ? (gain / baseOut) * 100 : 0;

      // Human-readable Δ text (display only; calculations use full precision)
      let deltaText = "";
      if (m.key === "dazeVulnMult") {
        const step = 0.05 * (deltaCfg.raw.pct / 5);
        deltaText = `+${fmt1(step)} mult`;
      } else if (m.key === "atkFlatBonus") {
        deltaText = `+${fmt1(applied.value)} ATK`;
      } else if (applied.kind === "flat") {
        deltaText = `+${fmt1(applied.value)} (flat)`;
      } else {
        deltaText = `+${fmt1(applied.value)}%`;
      }

      rows.push({ ...m, deltaText, out2, gain, pctGain });
    }

    rows.sort((a,b) => b.pctGain - a.pctGain);
    return { base, rows };
  }

  // ===========================
  // Save/Load/Export/Import
  // ===========================
  function saveBuild() {
    const data = readInputs();
    const key = storageKey(data.enemyPresetId);
    const existing = JSON.parse(localStorage.getItem(key) || "[]");
    const idx = existing.findIndex(x => x.buildName === data.buildName);
    if (idx >= 0) existing[idx] = data; else existing.push(data);
    localStorage.setItem(key, JSON.stringify(existing));
    alert(`Saved "${data.buildName}" under "${data.enemyPresetId}".`);
  }

  function loadBuild() {
    const enemyPresetId = $("enemyPresetId").value.trim() || "enemy_default";
    const key = storageKey(enemyPresetId);
    const existing = JSON.parse(localStorage.getItem(key) || "[]");
    if (!existing.length) return alert("No saved builds for this enemyPresetId.");
    const name = $("buildName").value.trim();
    const data = existing.find(x => x.buildName === name) || existing[0];
    applyInputs(data);
    refresh();
    alert(`Loaded "${data.buildName}".`);
  }

  function exportJSON() {
    const data = readInputs();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${(data.buildName || "build").replaceAll(" ", "_")}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function importJSONFile(file) {
    const r = new FileReader();
    r.onload = () => {
      try { applyInputs(JSON.parse(r.result)); refresh(); }
      catch { alert("Invalid JSON."); }
    };
    r.readAsText(file);
  }

  // ===========================
  // Apply inputs to form
  // ===========================
  function setVal(id, v) { $(id).value = v; }
  function setChk(id, v) { $(id).checked = !!v; }

  function applyInputs(d) {
    setVal("buildName", d.buildName ?? "My Build");
    setVal("enemyPresetId", d.enemyPresetId ?? "enemy_default");
    setVal("mode", d.mode ?? "standard");

    setVal("agentLevel", d.agent?.level ?? 60);
    setVal("atkBase", d.agent?.atkBase ?? d.agent?.atkFlat ?? 2000);
    setVal("atkFlatBonus", d.agent?.atkFlatBonus ?? 0);
    setVal("skillMultPct", d.agent?.skillMultPct ?? 300);
    setVal("critRatePct", ((d.agent?.crit?.rate ?? 0.5) * 100));
    setVal("critDmgPct", ((d.agent?.crit?.dmg ?? 1.0) * 100));
    setVal("attribute", d.agent?.attribute ?? "physical");
    setVal("specialMult", d.agent?.specialMult ?? 1);
const b = d.agent?.dmgBuckets ?? {};
    setVal("dmgGenericPct", b.generic ?? 0);
    setVal("dmgAttrPct", b.attribute ?? 0);
    setVal("dmgSkillTypePct", b.skillType ?? 0);
    setVal("dmgOtherPct", b.other ?? 0);
    setVal("dmgVsStunnedPct", b.vsStunned ?? 0);
    setVal("anomDmgPct", b.anomaly ?? 0);
    setVal("disorderDmgPct", b.disorder ?? 0);

    setVal("enemyLevel", d.enemy?.level ?? 60);
    setVal("enemyDef", d.enemy?.def ?? 0);
    setVal("enemyResPct", d.enemy?.resPct ?? 0);
    setVal("defReductionPct", d.enemy?.defReductionPct ?? 0);
    setVal("penRatioPct", d.agent?.penRatioPct ?? 0);
    setVal("penFlat", d.agent?.penFlat ?? 0);
    setVal("defIgnorePct", d.agent?.defIgnorePct ?? 0);

    const defOverride = (d.enemy?.defMultOverride !== undefined && d.enemy?.defMultOverride !== null)
      ? d.enemy.defMultOverride
      : ((d.enemy?.useManualDefMult) ? (d.enemy?.defMultManual ?? 1) : null);
    setVal("defMultOverride", defOverride ?? "");
    setVal("enemyDmgTakenMult", (d.enemy?.enemyDmgTakenMult ?? "") );

    setVal("dmgTakenPct", d.enemy?.dmgTakenPct ?? 0);
    setVal("isStunned", String(!!d.enemy?.stunned));
    setVal("stunPct", d.enemy?.stunPct ?? 100);
    setVal("dmgTakenStunnedPct", d.enemy?.dmgTakenStunnedPct ?? 0);
    setVal("dazeVulnMult", d.enemy?.dazeVulnMult ?? 1);

    setVal("sheerForce", d.agent?.rupture?.sheerForce ?? 0);
    setVal("sheerDmgBonusPct", d.agent?.rupture?.sheerDmgBonusPct ?? 0);
    setVal("atkToSheerPct", d.agent?.rupture?.atkToSheerPct ?? 30);

    setVal("anomMastery", d.agent?.anomaly?.mastery ?? 0);
    setVal("anomProf", d.agent?.anomaly?.proficiency ?? 0);
    setVal("anomBaseManual", d.agent?.anomaly?.baseManual ?? 0);
    setVal("anomTriggersPerRot", d.agent?.anomaly?.triggersPerRot ?? 0);
    setVal("disorderTriggersPerRot", d.agent?.anomaly?.disorderTriggersPerRot ?? 0);
    setVal("anomSpecialMult", d.agent?.anomaly?.specialMult ?? 1);
  }

  function resetAll() {
    applyInputs({
      buildName: "My Build",
      enemyPresetId: "enemy_default",
      mode: "standard",
      agent: {
        level: 60,
        atkBase: 2000, atkFlatBonus: 0, attribute: "physical",
        skillMultPct: 300, specialMult: 1,
        crit: { rate: 0.5, dmg: 1.0 },
        dmgBuckets: { generic:0, attribute:0, skillType:0, other:0, vsStunned:0, anomaly:0, disorder:0 },
        penRatioPct: 0, penFlat: 0, defIgnorePct: 0,
        rupture: { sheerForce: 0, sheerDmgBonusPct: 0, atkToSheerPct: 30 },
        anomaly: { mastery: 0, proficiency: 0, baseManual: 0, triggersPerRot: 0, disorderTriggersPerRot: 0, specialMult: 1 }
      },
      enemy: {
        level: 60, def: 0, resPct: 0,
        defReductionPct: 0, defMultOverride: null, enemyDmgTakenMult: null,
        dmgTakenPct: 0, stunned: false, stunPct: 100, dmgTakenStunnedPct: 0, dazeVulnMult: 1
      },
      meta: {}
    });
    refresh();
  }

  // ===========================
  // Visibility controls
  // ===========================
  function applyModeVisibility(mode) {
    const showAnom = (mode === "anomaly" || mode === "hybrid");
    const showRupture = (mode === "rupture");
    $("anomalyHeader").classList.toggle("hidden", !showAnom);
    $("anomalyCard").classList.toggle("hidden", !showAnom);
    $("ruptureHeader").classList.toggle("hidden", !showRupture);
    $("ruptureCard").classList.toggle("hidden", !showRupture);
  }

  // ===========================
  // Render
  // ===========================
  function refresh() {
    const i = readInputs();
    applyModeVisibility(i.mode);

    const out = computePreviewOutput(i);
    const z = out.zones;

    $("kpi").innerHTML = [
      { t:"Output (AVG)", v: fmt0(out.output_expected) },
            { t:"Output (Normal)", v: fmt0(out.output_noncrit) },
      { t:"Output (Crit)", v: fmt0(out.output_crit) },
      { t:"Anomaly Total", v: fmt0(out.anomaly_total) },
      { t:"Rupture Total", v: fmt0(out.rupture_total) },
    ].map(x => `<div class="box"><div class="t">${x.t}</div><div class="v">${x.v}</div></div>`).join("");

    
// Marginals
    const { base, rows } = computeMarginals(i);
    const topN = Number($("topN").value);
    const shown = rows.slice(0, topN);

    $("marginalBody").innerHTML = shown.map(r => `
      <tr>
        <td>${r.label}</td>
        <td>${r.deltaText}</td>
        <td>${fmt0(r.out2)}</td>
        <td>${fmt1(r.gain)}</td>
        <td>${fmt1(r.pctGain)}%</td>
        <td class="muted">${r.why}</td>
      </tr>
    `).join("");
  }

  // ===========================
  // Wire events
  // ===========================
  $("btnSave").addEventListener("click", () => { saveBuild(); refresh(); });
  $("btnLoad").addEventListener("click", () => { loadBuild(); refresh(); });
  $("btnExport").addEventListener("click", exportJSON);
  $("btnImport").addEventListener("click", () => $("importFile").click());
  $("importFile").addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if (f) importJSONFile(f);
    e.target.value = "";
  });
  $("btnReset").addEventListener("click", resetAll);

  document.querySelectorAll("input, select").forEach(el => {
    el.addEventListener("input", refresh);
    el.addEventListener("change", refresh);
  });

  // Init
  refresh();
</script>
</body>
</html>
